'\" t
.\"     srecord - The "srecord" program.
.\"     Copyright (C) 2007 Peter Miller
.\"
.\"     This program is free software; you can redistribute it and/or modify
.\"     it under the terms of the GNU General Public License as published by
.\"     the Free Software Foundation; either version 2 of the License, or
.\"     (at your option) any later version.
.\"
.\"     This program is distributed in the hope that it will be useful,
.\"     but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"     GNU General Public License for more details.
.\"
.\"     You should have received a copy of the GNU General Public License
.\"     along with this program; if not, write to the Free Software
.\"     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
.\"
.\" MANIFEST: manual entry for the srec_examples command
.\"
.ds n) srec_examples
.TH srec_examples 1 SRecord "Reference Manual"
.SH NAME
srec_examples \- examples of how to use SRecord
.XX "srec_examples(1)" "examples of how to use SRecord"
.SH DESCRIPTION
The \f[I]srec_cat\fP command is very powerful, due to the ability to combine
the the input filters in almost unlimited ways.
This manual page describes a few of them.
.PP
This manual page descibes how to use the varios input files, input
filters and input generators.  For more complete details, see the
\f[I]srec_input\fP(1) manual page.
.SS Your Examples Wanted
If you have a clever way of using SRecord, or have solve a difficult
problem with SRecord, you could contribute to this manual page, making
it more useful for everyone.  Send an email to the email address at the
end of this manual page.
.SH CONVERTING FILE FORMATS
The simplest of the things \f[I]srec_cat\fP(1) can do is convert from
one EPROM file format to another.  Please keep in mind, as you read this
section, that you can do many of these things simultaneously in one
command.  They are only broken out separately to make them easier to
understand.
.SS Intel to Motorola
One of the simplest esamples is converting files from Intel hex format
to Motorola S-Record format:
.RS
.ft CW
srec_cat \f[I]intel-file\fP -intel -o \f[I]srec-file\fP
.ft R
.RE
Pick any two formats that SRecord understands,
it can convert between all of them.
(Except the assembler and C outputs which are write only.)
.SS Motorola to Intel
Converting the other way is just as simple:
.RS
.ft CW
srec_cat \f[I]srec-file\fP -o \f[I]intel-file\fP -intel
.ft R
.RE
The default format is Motorola S-Record format,
so it does not need to be specified.
.SS Different Shapes of the Same Format
It is regretably common that some addle-pated EPROM programmers only
implement a portion of the specification used to represent their hex
files.  For example, some compilers produce \(lqs19\(rq Motorola
data (that is, S1 data records with S9 start records, 16 bit address
fields) which would be OK except that some blockhead EPROM programmers insist
on \(lqs37\(rq Motorola data (that is, S3 data records with S7 start
records, 32 bit address fields).
.PP
It is possible to convert from one Motorola shape to another using the
\fB\-Address-Length\fP option:
.RS
srec_cat short.srec -o long.srec --address-length=4
.RE
This command says to use four byte (32-bit) addresses on output.
.PP
This section also applies to Intel hex files, as they, too, have the
ability to select from a variety of address widths.
.SS Line Lenths
From time to time you will come across a feeble-minded EPROM programmer
that can't cope with long SRecord lines, they assume that there will
only ever be 16 bytes of data per line, and barf when they see the
default 32 byte payloads that \f[I]srec_cat\fP(1) writes.
.PP
The Motorola S-record format definition permits up to 255 bytes of
payload.  All EPROM programmers \f[I]should\fP have sufficiently large
buffers to cope with records this big.  Few do.
.PP
The \-line-length option may be used to specify the maximum line length
(not including the newline) to be used on output.
For example, 16 byte payloads for Motorola hex
.RS
srec_cat long.srec -o short.s19 --line-length=46
.RE
The line length option interacts with the address length option, so some
tinkering to optimize for your particular situation many be necessary.
.SS Just the Data, Please
There are some bonehead EPROM programmers which can only cope with data
records, and are unable to cope with header records or start address
records.  If you have the problem, the \fB\-data-only\fP option can be
uased to suppress just about everything except the data.  The actual
effect depends on the format, of couse, because some don't have these
features anyway.
.SS Data Headers
The \f[I]srec_cat\fP(1) command always tries to pass through header
records unchanged, whenever they are present.
It even tries preserve them across file format changes,
to the limit the file formats are capable of.
.PP
If there is no file header record and you would like to add one,
or you which to override an existing file header record, use the
\fB\-header\fP=\f[I]string\fP option.  You will need to quote the
string (to insulate it from the shell) if it contains spaces or shell
meta-characters.
.SS Start Addresses
The \f[I]srec_cat\fP(1) command always tries to pass through start
addresses (typically occuring at the end of the file), whenever they
are present.  They are adjusted along with the data records by the
\fB\-offset\fP filter.  It even tries preserve them across file format
changes, to the limit the file formats are capable of.
.PP
If there is no start address record and you would like to add one,
or you which to override an existing start address record, use the
\fB\-start-address\fP=\f[I]number\fP option.
.SS Fixing Checksums
Some emebedded firmware developers are saddled with featherbrained tools
which produce incorrect checksums, which the more vigilant models of
EPROM programmer will not accept.
.PP
To fix the checksums on a file, use the \fB\-ignore-checksums\fP option.
For example:
.RS
srec_cat broken.srec --ignore-checksums -o fixed.srec
.RE
The checksums in \f[I]broken.srec\fP are parsed (it is still
and error if they are absent) but are not checked.  The
resulting \f[I]fixed.srec\fP file has correct checksums.  The
\fB\-ignore-checksums\fP option only applies to input.
.PP
This option may be used on any file format which has checksums,
including Intel hex.
.\" ------------------------------------------------------------------------
.SH JOINING FILES TOGETHER
The \f[I]srec_cat\fP command takes its name from the UNIX \f[I]cat\fP(1)
command, which is short for 'catenate' or 'to join'.
The \f[I]srec_cat\fP command joins EPROM load files together.
.SS Joining Files Together
Joining EPROM load files together into a single file is simple, just
name as many files on the command line as you need:
.RS
.ft CW
srec_cat \f[I]infile1\fP \f[I]infile2\fP -o \f[I]outfile\fP
.ft R
.RE
This example is all Motorola S-Record files, because that's the
default format.  You can have multiple formats in the one command, and
\f[I]srec_cat\fP(1) will still work.  You don't even have to output the
same format:
.RS
.nf
srec_cat \f[I]infile1\fP -spectrum \f[I]infile2\fP -needham \e
    -o \f[I]outfile\fP -signetics
.fi
.RE
These are all ancient formats, however it isn't uncommon to have to mix
and match Intel and Motorola formats in the one project.
.SS Joining End-to-End
All too often the address ranges in the EPROM load files will overlap.
You will get an error if they do.
If both files start from address zero, because each goes into a separate
EPROM, you may need to use the offset filter:
.RS
.ft CW
.nf
srec_cat \f[I]infile1\fP \e
    \f[I]infile2\fP -offset 0x80000 \e
    -o \f[I]outfile\fP
.fi
.ft R
.RE
Sometimes you want the two files to follow each other exactly,
but you don't know the offset in advance:
.RS
.ft CW
.nf
srec_cat \f[I]infile1\fP \e
    \f[I]infile2\fP -offset -maximum \f[I]infile1\fP \e
    -o \f[I]outfile\fP
.fi
.ft R
.RE
Notice that where the was a number (0x80000) before, there is now a
calculation (\-maximum \f[I]infile1\fP).  This is possible most places
a number may be used (also \-minimum and \-range).
.\" ------------------------------------------------------------------------
.SH CROPPING THE DATA
It is possible to copy an EPROM load file,
selecting addresses to keep and addresses to discard.
.SS Cropping the Data
A common activity is to crop your data to match your EPROM location.
Your linker may add other junk that you are not interested in, \f[I]e.g.\fP
at the RAM location.  In this example, there is a 1MB EPROM at the 2MB
boundary:
.RS
.ft CW
.nf
srec_cat \f[I]infile\fP -crop 0x200000 0x300000 \e
    -o \f[I]outfile\fP
.fi
.ft R
.RE
The lower bound for all address ranges is inclusive, the upper bound is
exclusive.  If you subtract them, you get the number of bytes.
.SS Address Offset
Just possibly, you have a moronic EPROM programmer, and it barfs if the
EPROM image doesn't start at zero.  Rather than butcher the linker command file,
just offset the addresses:
.RS
.ft CW
.nf
srec_cat \f[I]infile\fP -crop 0x200000 0x300000 -offset -0x200000 \e
    -o \f[I]outfile\fP
.fi
.ft R
.RE
Note that the offset given is \f[I]negative\fP, it has the effect of
subtracting that value from all addresses in the input records, to form
the output record addresses.  In this case, shifting the image back to zero.
.PP
This example also demonstrates how the input filters may be chained
together: first the crop and then the offset, all in one command,
without the need for temporary files.
.SS Excluding Some Data
There are times when you need to exclude an small address range from an
EPROM load file, rather than wanting to keep a small address range.
The \fB\-exclude\fP filter may be used for this purpose.
.PP
For example, if you wish to exclude the address range where the serial
number of an embedded device is kept, say 0x20 bytes at 0x100, you would use
a command like this:
.RS
srec_cat input.srec -exclude 0x100 0x120 -o output.srec
.RE
The \f[I]output.srec\fP file will have a hole in the data at the
necessary locations.
.PP
Note that you can have both \-crop and \-exclude on the same command line,
whichever works more naturally for your situation.
.SS Discontinuous Address Ranges
Address ranges don't have to be a single range, you can build up an
address range using more than a single pair.
.RS
.ft CW
.nf
srec_cat \f[I]infile\fP -crop 0x100 0x200 0x1000 0x1200 \e
    -o \f[I]outfile\fP
.fi
.ft R
.RE
This filter results in data from 0x100..0x1FF and data from
0x1000..0x1200 to pass through, the rest is dropped.  This is is more
efficient than chaining a \-crop and an \-exclude filter together.
.\" ------------------------------------------------------------------------
.SS Filling the Blanks
It is possible to fill the blanks where your data does not lie.
The simplest example of this fills the entire EPROM:
.RS
.ft CW
srec_cat \f[I]infile\fP -fill 0x00 0x200000 0x300000 -o \f[I]outfile\fP
.ft R
.RE
This example fills the holes, if any, with zeros.
You must specify a range \- with a 32-bit address space,
filling everything generates \f[I]huge\fP load files.
.PP
If you only want to fill the gaps in your data,
and don't want to fill the entire EPROM, try:
.RS
.ft CW
srec_cat \f[I]infile\fP -fill 0x00 -over \f[I]infile\fP -o \f[I]outfile\fP
.ft R
.RE
This example demonstrates the fact that wherever an address range may be
specified, the \fB\-over\fP and \fB\-within\fP options may be used.
.SS Unfilling the Blanks
It is common to need to \(lqunfill\(rq an eprom image after you read it out of
a chip.  Usually, it will have had all the holes filled with 0xFF (areas
of the EPROM you don't program show as 0xFF when you read them back).
.PP
To get rid of all the 0xFF bytes in the data, use this filter:
.RS
.ft CW
srec_cat \f[I]infile\fP -unfill 0xFF -o \f[I]outfile\fP
.ft R
.RE
This will get rid of \f[I]all\fP the 0xFF bytes, including the ones you
actually wanted in there.  There are two ways to deal with this.  First,
you can specify a minimum run length to the un-fill:
.RS
.ft CW
srec_cat \f[I]infile\fP -unfill 0xFF 5 -o \f[I]outfile\fP
.ft R
.RE
This says that runs of 1 to 4 bytes of 0xFF are OK, and that a hole
should only be created for runs of 5 or more 0xFF bytes in a row.
The second method is to re-fill over the intermediate gaps:
.RS
.ft CW
srec_cat \f[I]outile\fP -fill 0xFF -over \f[I]outfile\fP -o \f[I]outfile2\fP
.ft R
.RE
Which method you choose depends on your needs, and the shape of the data
in your EPROM.  You may need to combine both techniques.
.SS Splitting an Image
If you have a 16-bit data bus, but you are using two 8-bit EPROMs to
hold your firmware, you can generate the even and odd images by using
the \-SPlit filter.  Assuming your firmware is in the \f[I]firmware.hex\fP
file, use the following:
.RS
.nf
.ft CW
srec_cat firmware.hex -split 2 0 -o firmware.even.hex
srec_cat firmware.hex -split 2 1 -o firmware.odd.hex
.ft R
.fi
.RE
This will result in the two necessary EPROM images.  Note that the output
addresses are divided by the split multiple, so if your EPROM images
are at a particular offset (say 0x10000, in the following example),
you need to remove the offset, and then replace it...
.RS
.nf
.ft CW
.ta 0.5i 1i 1.5i
srec_cat firmware.hex \e
        -offset -0x10000 -split 2 0 \e
        -offset 0x10000 -o firmware.even.hex
srec_cat firmware.hex \e
        -offset -0x10000 -split 2 1 \e
        -offset 0x10000 -o firmware.odd.hex
.ft R
.fi
.RE
Note how the ability to apply multiple filters simplifies what would
otherwise be a much longer script.
.PP
A second use for the \-SPlit filter is memory striping.
In this example, the hardware requires that 512-byte blocks alternate
between 4 EPROMs.  Generating the 4 images would be done as follows:
.RS
.nf
.ft CW
srec_cat firmware.hex -split 0x800 0x000 0x200 -o firmware.0.hex
srec_cat firmware.hex -split 0x800 0x200 0x200 -o firmware.1.hex
srec_cat firmware.hex -split 0x800 0x400 0x200 -o firmware.2.hex
srec_cat firmware.hex -split 0x800 0x600 0x200 -o firmware.3.hex
.ft R
.fi
.RE
.PP
The unsplit filter may be used to reverse the effects of the split filter.
Note that the address range is expanded leaving holes between the stripes.
By using all the stripes, the complete input is reassembled, without
any holes.  For example, to reverse our previous 16-bit data bus example,
use the following command:
.RS
.nf
.ft CW
.ta 0.5i 1i 1.5i
srec_cat -o firmware.hex \e
        firmware.even.hex -unsplit 2 0 \e
        firmware.odd.hex  -unsplit 2 1
.ft R
.fi
.RE
.so z_copyright.so
.\" vim:ts=8:sw=4:et
